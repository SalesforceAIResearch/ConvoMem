package com.salesforce.crmmembench.evaluation.memory

import com.salesforce.crmmembench.questions.evidence.Conversation

/**
 * Result of answering a question through a memory system.
 * 
 * @param answer The answer to the question, or None if the system fails to respond
 * @param retrievedConversationIds List of conversation IDs that were retrieved/used to answer
 * @param inputTokens Optional number of input tokens used by the model
 * @param outputTokens Optional number of output tokens generated by the model
 * @param cost Optional cost of the model call in dollars
 * @param cachedInputTokens Optional number of cached input tokens used by the model
 * @param memorySystemResponses Raw responses from the memory system (e.g., mem0 search results)
 */
case class AnswerResult(
  answer: Option[String], 
  retrievedConversationIds: List[String],
  inputTokens: Option[Int] = None,
  outputTokens: Option[Int] = None,
  cost: Option[Double] = None,
  cachedInputTokens: Option[Int] = None,
  memorySystemResponses: List[String] = List.empty
)

/**
 * Abstract interface for different memory-based question answering systems.
 * 
 * This trait allows the evaluation framework to support multiple memory backends:
 * - LongContext: Full conversation context in prompt (current implementation)
 * - RAG: Retrieval-Augmented Generation with vector search
 * - mem0: External memory service integration
 * 
 * The interface is designed for efficient bulk operations:
 * 1. Load conversations once using addConversation/addConversations
 * 2. Answer multiple questions on the loaded conversations
 * 
 * This approach is particularly important for systems like mem0 that perform
 * expensive indexing operations when loading conversations.
 */
trait MemoryAnswerer {

  /**
   * Add a single conversation to the memory system.
   * 
   * @param conversation The conversation to add to memory
   */
  def addConversation(conversation: Conversation): Unit

  /**
   * Add multiple conversations to the memory system.
   * Default implementation adds them one by one, but implementations
   * can override for bulk optimizations.
   * 
   * @param conversations List of conversations to add to memory
   */
  def addConversations(conversations: List[Conversation]): Unit = {
    conversations.foreach(addConversation)
  }

  /**
   * Answer a single question based on the loaded conversations.
   * 
   * @param question The question to answer based on the memory
   * @param testCaseId The ID of the test case being run
   * @return AnswerResult containing the answer and retrieved conversation IDs
   */
  def answerQuestion(question: String, testCaseId: String): AnswerResult

  /**
   * Get the name/type of this memory answerer for logging and identification.
   * 
   * @return String identifier for this memory system (e.g., "long_context", "rag", "mem0")
   */
  def getMemoryType: String

  /**
   * Optional method to initialize or configure the memory system.
   * Default implementation does nothing - override if needed.
   */
  def initialize(): Unit = {}

  /**
   * Optional method to cleanup resources when done.
   * Default implementation does nothing - override if needed.
   */
  def cleanup(): Unit = {}

  /**
   * Clear all loaded conversations from memory.
   * Useful for resetting state between test runs.
   */
  def clearMemory(): Unit

}